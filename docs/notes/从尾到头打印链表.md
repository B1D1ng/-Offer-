# 题目
>输入一个链表，按链表从尾到头的顺序返回一个ArrayList

# 思路
## 1.头插法 
利用Java中ArrayList的特有功能add(int index,Object obj)在指定位置插入元素，遍历链表用以头插的方式逐个添加元素即可
```
/**
*    public class ListNode {
*        int val;
*        ListNode next = null;
*
*        ListNode(int val) {
*            this.val = val;
*        }
*    }
*
*/
import java.util.*;
import java.util.ArrayList;
public class Solution {
    public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        ArrayList<Integer> arr=new ArrayList<Integer>();
        while(listNode!=null){
            arr.add(0,listNode.val);
            listNode=listNode.next;
        }
        return arr;
    }
}
```
### 结果
>运行时间：15ms
>占用内存：9420k
## 2.数组反转
利用Java中的集合工具类Collections.reverse(List<?> list)实现反转
```
/**
*    public class ListNode {
*        int val;
*        ListNode next = null;
*
*        ListNode(int val) {
*            this.val = val;
*        }
*    }
*
*/
import java.util.*;
import java.util.ArrayList;
public class Solution {
    public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
    /*
    int capacity = 0;
    ListNode pt = listNode;
    while(pt!=null){
    capacity++;
    pt = pt.next;
    }
     */
        ArrayList<Integer>arrayList = new ArrayList<>();
         while(listNode!=null){
            arrayList.add(listNode.val);
            listNode = listNode.next;
        }
        Collections.reverse(arrayList);
        return arrayList;
    }
}
```
### 结果
>运行时间：16ms
>占用内存：9172k

# 总结
由结果我们可以看出，当链表元素较少时，两种方法的效率相差无几，但当链表元素较多时，由于头插法需要将第一个元素之后的所有元素右移一位，这个开销是十分巨大的！另外，对于第二种方式，由ArrayList的扩容机制我们知道，ArrayList每次扩容后的容量是原来的1.5倍，如果链表中的元素过多，那么就会频繁地进行扩容，性能会有所降低，因此，使用ArrayList的时候最好在初始化时就确定所需容量大小，代码的注释部分补上了确定数组容量的代码。
